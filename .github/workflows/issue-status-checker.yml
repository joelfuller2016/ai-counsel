name: Issue Status Checker & Auto-Fix

# Comprehensive workflow to monitor issue lifecycle and ensure automation completion
# Runs every 15 minutes and on manual trigger

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: false
        default: 'check-all'
        type: choice
        options:
          - check-all
          - process-unplanned
          - escalate-stale
          - force-copilot-all
          - force-openhands-all
          - report-only

permissions:
  issues: write
  contents: write
  pull-requests: write

env:
  GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
  STALE_HOURS: 4  # Hours before escalating from Copilot to OpenHands
  MAX_ISSUES_PER_RUN: 50

jobs:
  # JOB 1: Check all open issues and categorize them
  analyze-issues:
    runs-on: ubuntu-latest
    outputs:
      unplanned: ${{ steps.analyze.outputs.unplanned }}
      planned_no_copilot: ${{ steps.analyze.outputs.planned_no_copilot }}
      copilot_stale: ${{ steps.analyze.outputs.copilot_stale }}
      has_pr: ${{ steps.analyze.outputs.has_pr }}
      report: ${{ steps.analyze.outputs.report }}
    steps:
      - name: Analyze all open issues
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const now = new Date();
            const STALE_MS = parseInt('${{ env.STALE_HOURS }}') * 60 * 60 * 1000;

            // Get all open issues
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            // Filter to actual issues (not PRs)
            const realIssues = issues.filter(i => !i.pull_request);

            // Get all open PRs to check for linked issues
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            // Extract issue numbers linked in PRs
            const linkedIssues = new Set();
            for (const pr of prs) {
              const body = (pr.body || '') + (pr.title || '');
              const matches = body.matchAll(/(fix(es)?|close(s)?|resolve(s)?)\s*#(\d+)/gi);
              for (const m of matches) linkedIssues.add(parseInt(m[4] || m[5]));
              // Also check simple #123 references
              const refs = body.matchAll(/#(\d+)/g);
              for (const r of refs) linkedIssues.add(parseInt(r[1]));
            }

            const categories = {
              unplanned: [],           // No CodeRabbit plan
              planned_no_copilot: [],  // Has plan but no Copilot
              copilot_stale: [],       // Copilot assigned but stale
              has_pr: [],              // Has linked PR
              completed: []            // Ready to close
            };

            for (const issue of realIssues) {
              const labels = issue.labels.map(l => l.name);
              const issueNum = issue.number;

              // Check if has linked PR
              if (linkedIssues.has(issueNum)) {
                categories.has_pr.push(issueNum);
                continue;
              }

              // Get comments to check for CodeRabbit plan
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNum,
                per_page: 50
              });

              const hasCodeRabbitPlan = comments.some(c =>
                c.user.login.includes('coderabbit') &&
                c.body.length > 500 &&
                (c.body.includes('## Implementation') ||
                 c.body.includes('## Coding Plan') ||
                 c.body.includes('### Phase') ||
                 c.body.includes('Prompt for AI'))
              );

              // Categorize
              if (!hasCodeRabbitPlan && !labels.includes('needs-plan')) {
                categories.unplanned.push(issueNum);
              } else if (hasCodeRabbitPlan && !labels.includes('copilot-assigned')) {
                categories.planned_no_copilot.push(issueNum);
              } else if (labels.includes('copilot-assigned')) {
                // Check if stale
                const copilotComment = comments.find(c =>
                  c.body.includes('Copilot Assigned') || c.body.includes('@copilot')
                );
                if (copilotComment) {
                  const elapsed = now - new Date(copilotComment.created_at);
                  if (elapsed > STALE_MS && !labels.includes('escalated-to-openhands')) {
                    categories.copilot_stale.push(issueNum);
                  }
                }
              }
            }

            // Generate report
            const report = [
              '## Issue Status Report',
              '',
              `**Total Open Issues:** ${realIssues.length}`,
              `**With Linked PRs:** ${categories.has_pr.length}`,
              '',
              '### Action Required',
              `- **Unplanned (need CodeRabbit):** ${categories.unplanned.length} [${categories.unplanned.join(', ')}]`,
              `- **Planned, awaiting Copilot:** ${categories.planned_no_copilot.length} [${categories.planned_no_copilot.join(', ')}]`,
              `- **Copilot Stale (>${'${{ env.STALE_HOURS }}'}h):** ${categories.copilot_stale.length} [${categories.copilot_stale.join(', ')}]`,
              '',
              `*Checked at ${now.toISOString()}*`
            ].join('\n');

            console.log(report);

            core.setOutput('unplanned', categories.unplanned.slice(0, 50).join(','));
            core.setOutput('planned_no_copilot', categories.planned_no_copilot.slice(0, 50).join(','));
            core.setOutput('copilot_stale', categories.copilot_stale.slice(0, 50).join(','));
            core.setOutput('has_pr', categories.has_pr.join(','));
            core.setOutput('report', report);

  # JOB 2: Request CodeRabbit plans for unplanned issues
  process-unplanned:
    needs: analyze-issues
    runs-on: ubuntu-latest
    if: needs.analyze-issues.outputs.unplanned != ''
    steps:
      - name: Request CodeRabbit plans
        uses: actions/github-script@v7
        with:
          script: |
            const issues = '${{ needs.analyze-issues.outputs.unplanned }}'.split(',').filter(Boolean);
            console.log(`Processing ${issues.length} unplanned issues`);

            for (const issueNum of issues) {
              console.log(`Requesting plan for issue #${issueNum}`);

              // Add labels
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNum),
                labels: ['auto-implement', 'needs-plan', 'stage-1-planning']
              });

              // Request CodeRabbit plan
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(issueNum),
                body: [
                  '## Automation Pipeline - Plan Request',
                  '',
                  '@coderabbitai Please create a detailed implementation plan:',
                  '',
                  '1. **Requirements Analysis** - What needs to be done',
                  '2. **Implementation Steps** - Step by step approach',
                  '3. **Files to Modify** - Which files need changes',
                  '4. **Test Cases** - What tests to add',
                  '5. **Acceptance Criteria** - How to verify completion',
                  '',
                  '*Once plan is ready, Copilot will be auto-assigned.*'
                ].join('\n')
              });

              await new Promise(r => setTimeout(r, 1000));
            }

  # JOB 3: Assign Copilot to planned issues (using gh CLI for proper assignment)
  assign-copilot:
    needs: analyze-issues
    runs-on: ubuntu-latest
    if: needs.analyze-issues.outputs.planned_no_copilot != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Assign Copilot to planned issues
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
        run: |
          ISSUES="${{ needs.analyze-issues.outputs.planned_no_copilot }}"
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUES"

          for ISSUE_NUM in "${ISSUE_ARRAY[@]}"; do
            if [ -z "$ISSUE_NUM" ]; then continue; fi

            echo "=== Processing issue #$ISSUE_NUM ==="

            # Try to assign Copilot using gh API
            echo "Attempting to assign copilot-swe-agent..."
            gh api repos/${{ github.repository }}/issues/$ISSUE_NUM/assignees \
              -X POST \
              -f 'assignees[]=copilot-swe-agent' 2>&1 || echo "Assignment via API failed, trying alternate method"

            # Update labels
            gh issue edit $ISSUE_NUM --add-label "copilot-assigned,stage-2-implementation,in-progress" --remove-label "needs-plan" 2>&1 || true

            # Add implementation request comment
            gh issue comment $ISSUE_NUM --body "## Plan Ready - Copilot Assigned

@copilot Please implement this issue following the CodeRabbit plan above.

**Requirements:**
- Follow the implementation plan exactly
- Include unit tests (xUnit + NSubstitute)
- Create PR with \`Fixes #$ISSUE_NUM\` in description

*If no PR in 4 hours, @openhands-agent will take over.*"

            echo "Processed issue #$ISSUE_NUM"
            sleep 1
          done

  # JOB 4: Escalate stale issues to OpenHands
  escalate-stale:
    needs: analyze-issues
    runs-on: ubuntu-latest
    if: needs.analyze-issues.outputs.copilot_stale != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Escalate to OpenHands
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUES="${{ needs.analyze-issues.outputs.copilot_stale }}"
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUES"

          for ISSUE_NUM in "${ISSUE_ARRAY[@]}"; do
            if [ -z "$ISSUE_NUM" ]; then continue; fi

            echo "Escalating issue #$ISSUE_NUM to OpenHands"

            # Add labels
            gh issue edit $ISSUE_NUM --add-label "fix-me,escalated-to-openhands,stage-3-escalation"

            # Add escalation comment
            gh issue comment $ISSUE_NUM --body "## Escalation to OpenHands

Copilot has not created a PR within the timeout period.

@openhands-agent Please implement this issue now:

1. Review the CodeRabbit plan above
2. Implement the solution
3. Include comprehensive tests
4. Create PR with \`Fixes #$ISSUE_NUM\` in description

*This is an automated escalation.*"

            sleep 1
          done

  # JOB 5: Check PRs have proper issue linking
  check-pr-linking:
    runs-on: ubuntu-latest
    steps:
      - name: Verify PR-Issue linking
        uses: actions/github-script@v7
        with:
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 50
            });

            for (const pr of prs) {
              const body = pr.body || '';
              const hasFixesLink = /fix(es)?\s*#\d+/i.test(body);
              const hasClosesLink = /close(s)?\s*#\d+/i.test(body);
              const hasResolvesLink = /resolve(s)?\s*#\d+/i.test(body);

              if (!hasFixesLink && !hasClosesLink && !hasResolvesLink) {
                console.log(`PR #${pr.number} missing issue link`);

                // Check if already warned
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  per_page: 20
                });

                const alreadyWarned = comments.some(c =>
                  c.body.includes('Missing Issue Link')
                );

                if (!alreadyWarned) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    body: [
                      '## Missing Issue Link',
                      '',
                      'This PR does not appear to be linked to an issue.',
                      '',
                      'Please add one of the following to the PR description:',
                      '- `Fixes #123` - closes the issue when merged',
                      '- `Closes #123` - closes the issue when merged',
                      '- `Resolves #123` - closes the issue when merged',
                      '',
                      '*This ensures proper tracking and auto-closes issues on merge.*'
                    ].join('\n')
                  });

                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: pr.number,
                    labels: ['needs-issue-link']
                  });
                }
              }
            }

  # JOB 6: Force Copilot on all issues (manual trigger)
  force-copilot-all:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'force-copilot-all'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get issues without Copilot assignment
        id: get-issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all open issues that don't have copilot-assigned label
          ISSUES=$(gh issue list --state open --limit 100 --json number,labels \
            --jq '[.[] | select(.labels | map(.name) | contains(["copilot-assigned"]) | not) | .number] | join(",")')
          echo "issues=$ISSUES" >> $GITHUB_OUTPUT
          echo "Found issues without copilot-assigned: $ISSUES"

      - name: Assign Copilot to all issues
        if: steps.get-issues.outputs.issues != ''
        env:
          GH_TOKEN: ${{ secrets.COPILOT_PAT || secrets.GITHUB_TOKEN }}
        run: |
          ISSUES="${{ steps.get-issues.outputs.issues }}"
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUES"

          COUNT=0
          for ISSUE_NUM in "${ISSUE_ARRAY[@]}"; do
            if [ -z "$ISSUE_NUM" ]; then continue; fi

            echo "=== Assigning Copilot to issue #$ISSUE_NUM ==="

            # Assign copilot-swe-agent using gh API
            gh api repos/${{ github.repository }}/issues/$ISSUE_NUM/assignees \
              -X POST \
              -f 'assignees[]=copilot-swe-agent' 2>&1 || echo "API assignment failed"

            # Add labels
            gh issue edit $ISSUE_NUM --add-label "copilot-assigned,in-progress" 2>&1 || true

            # Add implementation comment
            gh issue comment $ISSUE_NUM --body "## Copilot Implementation Request

@copilot Please implement this issue:

1. Analyze the requirements in the issue description
2. Review any CodeRabbit plan if present
3. Create a complete implementation with proper error handling
4. Include unit tests (xUnit + NSubstitute)
5. Create a PR with \`Fixes #$ISSUE_NUM\` in the description

*Automated assignment by force-copilot-all*"

            COUNT=$((COUNT + 1))
            echo "Assigned Copilot to issue #$ISSUE_NUM ($COUNT processed)"
            sleep 0.5
          done

          echo "Total issues processed: $COUNT"

  # JOB 7: Force OpenHands on all (manual trigger)
  force-openhands-all:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'force-openhands-all'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get issues without fix-me label
        id: get-issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Get all open issues that don't have fix-me label
          ISSUES=$(gh issue list --state open --limit 100 --json number,labels \
            --jq '[.[] | select(.labels | map(.name) | contains(["fix-me"]) | not) | .number] | join(",")')
          echo "issues=$ISSUES" >> $GITHUB_OUTPUT
          echo "Found issues without fix-me: $ISSUES"

      - name: Force OpenHands on all issues
        if: steps.get-issues.outputs.issues != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUES="${{ steps.get-issues.outputs.issues }}"
          IFS=',' read -ra ISSUE_ARRAY <<< "$ISSUES"

          COUNT=0
          for ISSUE_NUM in "${ISSUE_ARRAY[@]}"; do
            if [ -z "$ISSUE_NUM" ]; then continue; fi

            echo "Forcing OpenHands on issue #$ISSUE_NUM"

            # Add fix-me label
            gh issue edit $ISSUE_NUM --add-label "fix-me"

            # Add implementation comment
            gh issue comment $ISSUE_NUM --body "@openhands-agent Please implement this issue. Create PR with \`Fixes #$ISSUE_NUM\` in description."

            COUNT=$((COUNT + 1))
            sleep 0.5
          done

          echo "Total issues processed: $COUNT"
